# 原理
## 组件化

Muse是一个组件化的Canvas应用开发框架，你可以将复杂应用拆分成一个个独立的小组件，每个组件独立的实现自己的功能。这为Canvas组件资产沉淀提供了可能。

在Muse应用中，一切都是组件。每个组件都维护了一个自己的`Offscreen Canvas`，用以缓存自己的视图状态，当组件没有内容更新时，我们不用再次绘制这个组件的内容。

## 更新算法

复杂应用会由多个组件构成，这些组件构成了一个组件树。当组件树中某个或多个组件发生了更新时，我们需要统筹一个更新链路，以保证根结点的真实`Canvas`视图更新。

### 更新前

一个组件的内容更新有三种来源：

1. 父组件传递一个新的`Props`参数，同时这个参数被该组件的`render`方法使用；
2. 组件内部的`State`参数更新，同时这个参数被该组件的`render`方法使用；
3. 子组件的内容出现了更新，且这个子组件被该组件的`render`方法使用。

### 组件更新

当组件需要更新时，它会执行一次`render`方法来保证自己的视图更新，这个时候我们会使用到子组件的视图内容。如果子组件的内容已经过期（比如传递的`Props`改变了），我们会等待子组件的更新，并在子组件上递归上述过程；如果子组件的内容没有过期，我们会直接使用子组件的`Offscreen Canvas`内容。

### 组件树更新

当组件更新后，其父亲组件，以及父亲组件的父亲组件等都会变成过期状态，这是因为子组件的内容会直接构成父亲组件的视图内容，其内容过期时，父亲组件的内容是没有意义的。因此，我们会标记着一条链路上所有组件为`Stale`过期状态，表示它们的内容待更新。

#### 1. 普通渲染

当组件树中某个子组件需要更新时，我们也需要通知它的父组件更新。

为了避免在同一次主任务中多次渲染同一个组件，我们将所有的更新请求在根结点组件上收集起来，并且将本次待更新组件的所有父组件进行一次标记。

在收集完毕一次更新请求后，我们从根级组件开始进行更新，这个过程按照上文的[组件更新](#组件更新)算法进行。

#### 2. 局部渲染

在组件树比较复杂的场景，频繁的从根节点开始更新组件树是比较浪费性能的，因为父组件的内容没有更变，但是[普通渲染](#普通渲染)算法需要让这条更新链全部重新绘制一遍。因此我们可以让待更新组件**局部渲染**到根级组件的内容中，跳过父组件们的渲染。

但是这个局部渲染需要该组件满足以下几个条件，否者简单进行局部渲染会导致视图污染：

- 组件背景不是透明的；
- 待补充

当组件不满足上述条件时，我们会通知它的父组件进行局部渲染，并再次检查上述条件，直到找到一个符合条件的组件或者追溯到根级组件为止。

可以看出，最坏的情况就是没有一个组件满足局部渲染条件，这个时候我们的更新算法就退化到了[普通渲染](#普通渲染)算法。

但是需要注意的是，当组件被其它组件覆盖时，进行局部渲染会导致应用的图层关系错误。所以当一个组件进行局部渲染时，我们需要通知所有覆盖在上层的组件按绘制顺序进行局部渲染。

值得注意的是，当组件的覆盖关系过于复杂的时候，整体的更新算法复杂度可能会超过[普通渲染](#普通渲染)算法。所以我们应该尽量在无/少覆盖关系的组件上开启局部渲染算法。

## 覆盖树算法

前面提到，当组件进行局部渲染时，我们需要通知到所有与之有覆盖关系的组件也进行局部渲染，所以我们需要一个算法来快速计算出组件之间的覆盖关系。

## 事件系统

## 动画
