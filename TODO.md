## TODO LIST

- ~~覆盖树算法~~

- 切片渲染
- hooks
  - 已实现 useElement

- 后处理算法待验证
- 插槽在初次渲染不生效，和多点更新问题需要一起看一下

### 待讨论

- 子组件的宽高应不应该由父级决定？
  -- 不应该，因为组件绘图时不知道自己的尺寸

- 也许不需要局部渲染，因为使用offscreen canvas的成本不大，且为固定的（与canvas尺寸没太大关系）耗时 （有实验）
  从可维护性的角度上来说，组件树渲染更好
  - 后续实验发现在反复切换canvas渲染时，性能损耗非常大
    - 使用一个公共大canvas，都在同一个canvas上渲染，就避免了canvas切换
    - 使用无canvas组件，将自组件的渲染对象聚合 <<<
      - 现在的问题是，渲染顺序反过来了
      - translate需要嵌套
      - 组件更新时怎么处理？

- useElement进一步封装，可以直接当做函数一样使用组件

- 取消Muse，直接new根元素

- 思考一下这个框架的根本意义是什么
  - 组件化，可以抽离一个完全独立于外界的组件
    - 定位可以从(0, 0)开始
    - 可以有内部状态
    - 更新调度
  - 易用的事件系统
